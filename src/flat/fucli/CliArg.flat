package flat/fucli

import flat/log

class {
  static Logger log = Logger(CliArg.class)

  var Bool enabled = false

  this[String argName] => args.firstWhere({ _.name == argName })

  var String value {
    get {
      return values.first
    }

    set {
      if (values.isEmpty) {
        values = [value]
      } else {
        values[0] = value
      }
    }
  }

  visible String[] values = Array<String>()

  public construct(
    String name,
    String[] aliases = Array<String>(),
    Int: count = 0,
    String: description = null,
    CliArg[]: args = null,
    Bool: wildcard = false
  ) {
    this(
      name,
      aliases,
      minCount: count,
      maxCount: count,
      description: description,
      args: args,
      wildcard: wildcard
    )
  }

  public construct(
    String name,
    Int: minCount,
    Int: maxCount = -1,
    String: description = null,
    CliArg[]: args = null,
    Bool: wildcard = false
  ) {
    this(
      name,
      Array<String>(),
      minCount: minCount,
      maxCount: maxCount,
      description: description,
      args: args,
      wildcard: wildcard
    )
  }

  public construct(
    visible String name,
    visible String[] aliases,
    visible Int: minCount,
    visible Int: maxCount = -1,
    visible String: description = null,
    visible CliArg[]: args = null,
    visible Bool: wildcard = false
  ) {}

  public matches(String value) => wildcard || value == name || aliases.any({ value == _ })

  public getArg(String value) -> CliArg => null {
    if (!args) return null

    log.trace("Searching #{name} non-wildcard args: #{args.stream().filter({ !_.wildcard }).toArray()}")
    if (CliArg nonWildcardArg = args.stream().filter({ !_.wildcard }).filter({ _.matches(value) }).first) return nonWildcardArg
  }

  public getWildcardArg(String value) -> CliArg => null {
    if (!args) return null

    log.trace("Searching #{name} wildcard args: #{args.stream().filter({ _.wildcard }).toArray()}")
    if (CliArg wildcardMatch = args.stream().filter({ _.wildcard }).first) return wildcardMatch
  }

  static getUsageString(
    CliArg[] breadcrumbs,
    CliArg[] arguments,
    CliArg[] commands,
    CliArg[] options
  ) -> String {
    let usageValues = breadcrumbs.map({ _.name })

    if (arguments.isNotEmpty) {
      usageValues.add("<arguments>")
    }

    if (commands.isNotEmpty) {
      usageValues.add("<command>")
    }

    if (options.isNotEmpty) {
      usageValues.add("[options]")
    }

    return usageValues.join(" ")
  }

  public getHelp(
    CliArg[] breadcrumbs,
    Bool printHelpLine = true,
    Bool formatted = true
  ) -> CliArgHelp {
    var str = ""

    if (description) {
      str += "#{description}\n\n"
    }

    let gutterSize = 4
    let gutter = " ".repeat(gutterSize)

    let arguments = args?.filter({ _.wildcard }) ?: Array()
    let commands = args?.filter({ !_x.wildcard && !_x.name.startsWith("--") }) ?: Array()
    let options = args?.filter({ !_x.wildcard && _x.name.startsWith("--") }) ?: Array()

    let usage = getUsageString(breadcrumbs, arguments, commands, options)

    str += "|
      Usage:
      #{gutter}#{usage}
      |"

    let Int argumentsGutterSpace = arguments.max({ _x.name.count + 2 + (_x.aliases != null ? _x.aliases.sum({ _.count + 4 }) : 0) }) + gutterSize

    let argumentDescriptions = arguments.map((arg) => {
      let argName = "<#{arg.name}>"

      if (arg.description) {
        let argGutter = " ".repeat(argumentsGutterSpace - argName.count)
        return "#{gutter}#{argName}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argName}"
      }
    })

    if (argumentDescriptions.isNotEmpty) {
      str += "\n\nArguments:\n"
      str += argumentDescriptions.join("\n")
    }

    let Int commandsGutterSpace = commands.max({ _x.name.count + (_x.aliases != null ? _x.aliases.sum({ _.count + 2 }) : 0) }) + gutterSize

    let commandDescriptions = commands.map((arg) => {
      let aliases = arg.aliases?.isNotEmpty ? arg.aliases.stitchFront(", ") : ""
      let argNames = "#{arg.name}#{aliases}"

      if (arg.description) {
        let argGutter = " ".repeat(commandsGutterSpace - argNames.count)
        return "#{gutter}#{argNames}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argNames}"
      }
    })

    if (commandDescriptions.isNotEmpty) {
      str += "\n\nCommands:\n"
      str += commandDescriptions.join("\n")
    }

    let Int optionsGutterSpace = options.max({ _x.name.count + (_x.aliases != null ? _x.aliases.sum({ _.count + 2 }) : 0) }) + gutterSize

    let optionDescriptions = options.map((arg) => {
      let aliases = arg.aliases?.isNotEmpty ? arg.aliases.stitchFront(", ") : ""
      let argNames = "#{arg.name}#{aliases}"

      if (arg.description) {
        let argGutter = " ".repeat(optionsGutterSpace - argNames.count)
        return "#{gutter}#{argNames}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argNames}"
      }
    })

    if (optionDescriptions.isNotEmpty) {
      str += "\n\nOptions:\n"
      str += optionDescriptions.join("\n")
    }

    if (printHelpLine && (arguments.isNotEmpty || commands.isNotEmpty || options.isNotEmpty)) {
      let binaryName = breadcrumbs.first.name

      let types = Array<String>():addAll([
        arguments.isNotEmpty ? "argument" : null,
        commands.isNotEmpty ? "command" : null,
        options.isNotEmpty ? "option" : null,
      ]).filterNull()

      str += "\n\nSee '#{binaryName} help#{breadcrumbs.skip(1).stitchFront(" ")} <#{types.join("/")}>' for more information on a specific #{types.toEnglish("or")}"
    }

    return CliArgHelp(
      arg: this,
      breadcrumbs: breadcrumbs,
      help: str
    )
  }

  public getAllHelp(
    CliArg[] breadcrumbs,
    Bool formatted = true
  ) -> CliArgHelp[] {
    let help = [getHelp(breadcrumbs, false, formatted)]

    if (!args || args.isEmpty) return help

    return help:addAll(args.flatMap((arg) => {
      arg.getAllHelp(breadcrumbs.plus([arg]), formatted)
    }))
  }

  override public toString() => name {
    if (wildcard) return "<#{name}>"
    if (values.isNotEmpty) return "#{name} #{values.join(" ")}"
  }
}