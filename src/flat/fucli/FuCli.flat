package flat/fucli

import flat/log

class {
  static Logger log = Logger(FuCli.class)

  visible CliArg[] usedArgs = CliArg[]

  public construct(
    visible CliArg[] args,
    visible String: description = null,
    visible String: usage = null
  ) {}

  public parse(List<String> strArgs) {
    let argsIterator = strArgs.iterator

    while (argsIterator.hasNext) {
      let value = argsIterator.stepNext

      log.debug("Searching for arg for value \"#{value}\"")
      if (let arg = getArg(value)) {
        log.debug("Got arg for value \"#{value}\": #{arg}")
        usedArgs.add(arg)
        arg.enabled = true

        while (argsIterator.hasNext) {
          if (arg.values.count < arg.minCount) { // if not reached minimum values for argument yet
            arg.values.add(argsIterator.stepNext)
          } else if (arg.maxCount == -1 || arg.values.count < arg.maxCount) { // if not reached maximum values for argument yet
            if (getArg(argsIterator.next)) break

            arg.values.add(argsIterator.stepNext)
          } else {
            break
          }
        }

        if (arg.values.count < arg.minCount) {
          throw InvalidCliArgumentException(value)
        }
      } else {
        throw InvalidCliArgumentException(value)
      }
    }
  }

  getArg(String value) -> CliArg => null {
    if (let childArg = usedArgs.lastNonNull({ _.getArg(value) })) {
      return childArg
    }
    if (let globalArg = args.firstWhere({ _.matches(value) })) {
      return globalArg
    }
  }

  class InvalidCliArgumentException extends Exception {
    public construct(String argument) => super("Invalid CLI argument: '#argument'")
  }

  public getHelpString(
    Bool formatted = true
  ) -> String {
    var str = ""

    if (description) {
      str += description
    }

    let gutterSize = 4
    let gutter = " ".repeat(gutterSize)

    if (usage) {
      if (str.isNotEmpty) str += "\n\n"

      str += "|
        USAGE:
        #{gutter}#{usage}
        |"
    }

    let commands = args.filter({ !_.name.startsWith("--") })
    let options = args.filter({ _.name.startsWith("--") })

    let Int commandsGutterSpace = commands.max({ _x.name.count + (_x.aliases != null ? _x.aliases.sum({ _.count + 2 }) : 0) }) + gutterSize
    let Int optionsGutterSpace = options.max({ _x.name.count + (_x.aliases != null ? _x.aliases.sum({ _.count + 2 }) : 0) }) + gutterSize

    let commandDescriptions = commands.map((arg) => {
      let aliases = arg.aliases?.isNotEmpty ? arg.aliases.stitchFront(", ") : ""
      let argNames = "#{arg.name}#{aliases}"

      if (arg.description) {
        let argGutter = " ".repeat(commandsGutterSpace - argNames.count)
        return "#{gutter}#{argNames}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argNames}"
      }
    })

    if (commandDescriptions.isNotEmpty) {
      if (str.isNotEmpty) str += "\n\n"

      str += "COMMANDS:\n"
      str += commandDescriptions.join("\n")
    }

    let optionDescriptions = options.map((arg) => {
      let aliases = arg.aliases?.isNotEmpty ? arg.aliases.stitchFront(", ") : ""
      let argNames = "#{arg.name}#{aliases}"

      if (arg.description) {
        let argGutter = " ".repeat(optionsGutterSpace - argNames.count)
        return "#{gutter}#{argNames}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argNames}"
      }
    })

    if (optionDescriptions.isNotEmpty) {
      if (str.isNotEmpty) str += "\n\n"

      str += "OPTIONS:\n"
      str += optionDescriptions.join("\n")
    }

    return str
  }

  override public toString() => args.filter({ _.enabled }).join(" ")
}