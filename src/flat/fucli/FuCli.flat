package flat/fucli

import flat/log

class {
  static Logger log = Logger(FuCli.class)

  visible CliArg[] usedArgs = CliArg[]

  public construct(
    visible String binaryName,
    visible CliArg[] args,
    visible String: description = null
  ) {}

  public parse(List<String> strArgs) {
    let argsIterator = strArgs.iterator

    while (argsIterator.hasNext) {
      let value = argsIterator.stepNext

      log.debug("Searching for arg for value \"#{value}\"")
      if (let arg = getArg(value)) {
        log.debug("Got arg for value \"#{value}\": #{arg}")
        usedArgs.add(arg)
        arg.enabled = true

        while (argsIterator.hasNext) {
          if (arg.values.count < arg.minCount) { // if not reached minimum values for argument yet
            arg.values.add(argsIterator.stepNext)
          } else if (arg.maxCount == -1 || arg.values.count < arg.maxCount) { // if not reached maximum values for argument yet
            if (getArg(argsIterator.next)) break

            arg.values.add(argsIterator.stepNext)
          } else {
            break
          }
        }

        if (arg.values.count < arg.minCount) {
          throw InvalidCliArgumentException(value)
        }
      } else {
        throw InvalidCliArgumentException(value)
      }
    }
  }

  getArg(String value) -> CliArg => null {
    if (let childArg = usedArgs.lastNonNull({ _.getArg(value) })) {
      return childArg
    }
    if (let globalArg = args.firstWhere({ _.matches(value) })) {
      return globalArg
    }
  }

  class InvalidCliArgumentException extends Exception {
    public construct(String argument) => super("Invalid CLI argument: '#argument'")
  }

  public getHelpString(
    Bool formatted = true
  ) -> String {
    if (usedArgs.count == 1) {
      return getHelpString(binaryName, Array(), args, description, formatted)
    }

    let arg = usedArgs.last

    return getHelpString(
      binaryName,
      usedArgs.skip(1),
      arg.args ?: Array(),
      arg.description
    )
  }

  static getUsageString(
    String binaryName,
    CliArg[] breadcrumbs,
    CliArg[] commands,
    CliArg[] options
  ) -> String {
    let usageValues = [binaryName]

    usageValues.addAll(breadcrumbs.map({ _.name }))

    if (commands.isNotEmpty) {
      usageValues.add("<COMMAND>")
    }

    if (options.isNotEmpty) {
      usageValues.add("[OPTIONS]")
    }

    return usageValues.join(" ")
  }

  static getHelpString(
    String binaryName,
    CliArg[] breadcrumbs,
    CliArg[] args,
    String description,
    Bool formatted = true
  ) -> String {
    var str = ""

    if (description) {
      str += "#{description}\n\n"
    }

    let gutterSize = 4
    let gutter = " ".repeat(gutterSize)

    let commands = args.filter({ !_.name.startsWith("--") })
    let options = args.filter({ _.name.startsWith("--") })

    let usage = getUsageString(binaryName, breadcrumbs, commands, options)

    str += "|
      USAGE:
      #{gutter}#{usage}
      |"

    let Int commandsGutterSpace = commands.max({ _x.name.count + (_x.aliases != null ? _x.aliases.sum({ _.count + 2 }) : 0) }) + gutterSize
    let Int optionsGutterSpace = options.max({ _x.name.count + (_x.aliases != null ? _x.aliases.sum({ _.count + 2 }) : 0) }) + gutterSize

    let commandDescriptions = commands.map((arg) => {
      let aliases = arg.aliases?.isNotEmpty ? arg.aliases.stitchFront(", ") : ""
      let argNames = "#{arg.name}#{aliases}"

      if (arg.description) {
        let argGutter = " ".repeat(commandsGutterSpace - argNames.count)
        return "#{gutter}#{argNames}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argNames}"
      }
    })

    if (commandDescriptions.isNotEmpty) {
      str += "\n\nCOMMANDS:\n"
      str += commandDescriptions.join("\n")
    }

    let optionDescriptions = options.map((arg) => {
      let aliases = arg.aliases?.isNotEmpty ? arg.aliases.stitchFront(", ") : ""
      let argNames = "#{arg.name}#{aliases}"

      if (arg.description) {
        let argGutter = " ".repeat(optionsGutterSpace - argNames.count)
        return "#{gutter}#{argNames}#{argGutter}#{arg.description}"
      } else {
        return "#{gutter}#{argNames}"
      }
    })

    if (optionDescriptions.isNotEmpty) {
      str += "\n\nOPTIONS:\n"
      str += optionDescriptions.join("\n")
    }

    if (commands.isNotEmpty) {
      str += "\n\nSee '#{binaryName} help <COMMAND/OPTION>' for more information on a specific command or option"
    }

    return str
  }

  override public toString() => args.filter({ _.enabled }).join(" ")
}