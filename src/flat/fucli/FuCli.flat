package flat/fucli

import flat/log

class {
  static Logger log = Logger(FuCli.class)

  visible CliArg[] usedArgs = CliArg[]

  CliArg binaryArg

  visible String binaryName => binaryArg.name
  visible CliArg[] args => binaryArg.args
  visible String description => binaryArg.description

  this[String argName] => binaryArg[argName]

  public construct(
    String binaryName,
    CliArg[] args,
    String: description = null
  ) {
    binaryArg = CliArg(
      binaryName,
      description: description,
      args: args
    )
  }

  public parse(List<String> strArgs) {
    let argsIterator = strArgs.iterator

    while (argsIterator.hasNext) {
      let value = argsIterator.stepNext

      log.debug("Searching for arg for value \"#{value}\"")
      if (let arg = getArg(value)) {
        log.debug("Got arg for value \"#{value}\": #{arg}")
        usedArgs.add(arg)
        arg.enabled = true

        if (arg.wildcard) arg.values.add(value)

        while (argsIterator.hasNext) {
          if (arg.values.count < arg.minCount) { // if not reached minimum values for argument yet
            arg.values.add(argsIterator.stepNext)
          } else if (arg.maxCount == -1 || arg.values.count < arg.maxCount) { // if not reached maximum values for argument yet
            if (getArg(argsIterator.next)) break

            arg.values.add(argsIterator.stepNext)
          } else {
            break
          }
        }
      } else {
        throw InvalidCliArgumentException(value)
      }
    }

    if (usedArgs.isEmpty || usedArgs.first.name != "help") {
      usedArgs.forEach(validateArg)
    }
  }

  validateArg(CliArg arg) {
    log.debug("|
      Validating arg #{arg.name}
        required: #{arg.required}
        values: #{arg.values}
        minCount: #{arg.minCount}
        maxCount: #{arg.maxCount}
      |")
    if (arg.required && arg.values.count < arg.minCount) {
      throw RequiredCliArgumentException(arg)
    }

    if (!arg.args) return

    arg.args.forEach(validateArg)
  }

  getArg(String value) -> CliArg => null {
    if (CliArg childArg = usedArgs.last?.getArg(value)) return childArg
    if (CliArg globalArg = binaryArg.getArg(value)) return globalArg
    if (CliArg childWildcardArg = usedArgs.last?.getWildcardArg(value)) return childWildcardArg
    if (CliArg globalWildcardArg = binaryArg.getWildcardArg(value)) return globalWildcardArg
  }

  class InvalidCliArgumentException extends Exception {
    public construct(String argument) =>
      super("Invalid CLI argument: '#argument'")
  }

  class RequiredCliArgumentException extends Exception {
    public construct(CliArg arg) =>
      super(
        arg.minCount == 1
          ? "CLI argument #{arg} is required but was not given"
          : "#{arg.minCount} #{arg} CLI arguments are required but #{arg.values.count == 0 ? "0 were" : (arg.values.count == 1 ? "only 1 was" : "only #{arg.values.count} were")} given"
      )
  }

  public getHelp(
    Bool formatted = true
  ) -> CliArgHelp {
    let helpArgs = [binaryArg]
    helpArgs.addAll(usedArgs.skip(1))

    return helpArgs.last.getHelp(helpArgs)
  }

  public getAllHelp(
    Bool formatted = true
  ) -> CliArgHelp[] {
    let helpArgs = [binaryArg]
    helpArgs.addAll(usedArgs.skip(1))

    return helpArgs.last.getAllHelp(helpArgs)
  }

  override public toString() => args.filter({ _.enabled }).join(" ")
}